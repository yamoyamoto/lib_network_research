package main

import (
	"analyzer/datasource"
	"analyzer/models"
	"database/sql"
	"encoding/csv"
	"encoding/json"
	"fmt"
	_ "github.com/go-sql-driver/mysql"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
)

func DirWalk(dir string) ([]string, error) {
	files, err := ioutil.ReadDir(dir)
	if err != nil {
		return nil, fmt.Errorf("read dir: %w", err)
	}

	var paths []string
	for _, file := range files {
		if file.IsDir() {
			// Recursively calls Dirwalk in the case of a directory
			p, err := DirWalk(filepath.Join(dir, file.Name()))
			if err != nil {
				return nil, fmt.Errorf("dirwalk %s: %w", filepath.Join(dir, file.Name()), err)
			}
			// Merge into the caller's "paths" variable.
			paths = append(paths, p...)
			continue
		}
		// Now that we've reached a leaf (file) in the directory tree, we'll add it to "paths" variable.
		paths = append(paths, filepath.Join(dir, file.Name()))
	}

	return paths, nil
}

const (
	databaseDir    = "./advisory-database/advisories/github-reviewed/"
	outputFIlePath = "cargo_vul_data.csv"
)

func main() {
	if err := handler(); err != nil {
		panic(err)
	}
}

func handler() error {
	files, err := DirWalk(databaseDir)
	if err != nil {
		return err
	}

	db, err := sql.Open("mysql", "root@(localhost:3306)/lib")
	if err != nil {
		return err
	}

	reports := make([]VulReport, 0)
	for i, path := range files {
		if i%1000 == 0 {
			log.Printf("走査したファイル %d 件", i)
		}
		r, err := ParseCVEFile(db, "crates.io", path)
		if err != nil {
			//log.Printf("エラー: %s", err)
			continue
		}
		reports = append(reports, r...)
	}

	// バリデーション
	newReports := make([]VulReport, 0)
	for _, report := range reports {
		isDuplicate := false
		for i, newReport := range newReports {
			if newReport.Summary == report.Summary &&
				newReport.PackageName == report.PackageName &&
				newReport.ProjectId == report.ProjectId {
				isDuplicate = true
				if newReport.VersionRange == report.VersionRange {
				} else {
					log.Printf("marge version range")
					newReports[i].VersionRange = fmt.Sprintf("%s || %s", newReports[i].VersionRange, report.VersionRange)
				}
			}
		}
		if !isDuplicate {
			newReports = append(newReports, report)
		}
	}

	f, err := os.Create(outputFIlePath)
	if err != nil {
		return err
	}
	w := csv.NewWriter(f)
	if err := w.Write([]string{
		"vulnerability_name",
		"package_name",
		"version_range",
		"published_at",
		"project_id",
	}); err != nil {
		return err
	}

	for _, r := range newReports {
		if err := w.Write([]string{
			r.Summary,
			r.PackageName,
			r.VersionRange,
			r.PublishedAt,
			r.ProjectId,
		}); err != nil {
			return err
		}
	}
	w.Flush()

	return nil
}

type VulReport struct {
	Summary      string
	PackageName  string
	VersionRange string
	PublishedAt  string
	ProjectId    string
}

type RawCVEReport struct {
	Published string            `json:"published"`
	Summary   string            `json:"summary"`
	Affected  []AffectedPackage `json:"affected"`
}

type AffectedPackage struct {
	Package AffectedPackageDetail  `json:"package"`
	Ranges  []AffectedPackageRange `json:"ranges"`
}

type AffectedPackageDetail struct {
	Ecosystem string `json:"ecosystem"`
	Name      string `json:"name"`
}

type AffectedPackageRange struct {
	Type   string              `json:"type"`
	Events []map[string]string `json:"events"`
}

type VulRange struct {
	Introduced string
	Fixed      string
}

func ParseCVEFile(db *sql.DB, ecosystem string, path string) ([]VulReport, error) {
	b, err := GetFileContent(path)
	if err != nil {
		return nil, err
	}

	rawCveReport := RawCVEReport{}
	if err := json.Unmarshal(b, &rawCveReport); err != nil {
		return nil, err
	}

	vulReports := make([]VulReport, 0)
	ranges := make([]VulRange, 0)
	for _, af := range rawCveReport.Affected {
		if af.Package.Ecosystem != ecosystem {
			continue
		}

		for _, r := range af.Ranges {
			var introduced string
			var fixed string
			for _, e := range r.Events {
				i, ok := e["introduced"]
				if ok {
					introduced = ">=" + i
				}
				f, ok := e["fixed"]
				if ok {
					fixed = "<" + f
				}
			}
			ranges = append(ranges, VulRange{
				Introduced: introduced,
				Fixed:      fixed,
			})
		}

		for _, r := range ranges {
			projectId, err := datasource.GetPackageIdByName(db, models.Cargo, af.Package.Name)
			if err != nil {
				//log.Printf("error: %s", err)
				continue
			}

			vulReports = append(vulReports, VulReport{
				Summary:      rawCveReport.Summary,
				PackageName:  af.Package.Name,
				VersionRange: fmt.Sprintf("%s %s", r.Introduced, r.Fixed),
				PublishedAt:  rawCveReport.Published,
				ProjectId:    projectId,
			})
		}
	}

	return vulReports, nil
}

func GetFileContent(filePath string) ([]byte, error) {
	f, err := os.Open(filePath)
	if err != nil {
		return nil, err
	}
	defer func(f *os.File) {
		err := f.Close()
		if err != nil {
			panic(err)
		}
	}(f)

	return ioutil.ReadAll(f)
}
