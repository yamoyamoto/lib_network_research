package main

import (
	"analyzer/datasource"
	"analyzer/models"
	"database/sql"
	"encoding/csv"
	"fmt"
	"github.com/Masterminds/semver/v3"
	_ "github.com/go-sql-driver/mysql"
	"log"
	"os"
	"strings"
)

func main() {
	args := os.Args

	if err := buildVulDataWithAllVersions(args[1], args[2]); err != nil {
		panic(err)
	}
}

func buildVulDataWithAllVersions(filePath string, ecosystemName string) error {
	type VulRecord struct {
		VulName      string
		PackageName  string
		VersionRange string
		PublishedAt  string
		ProjectId    string
	}

	file, err := os.Open(filePath)
	if err != nil {
		return err
	}
	defer func(file *os.File) {
		err := file.Close()
		if err != nil {
			panic(err)
		}
	}(file)

	r := csv.NewReader(file)
	rows, err := r.ReadAll()
	if err != nil {
		return err
	}

	db, err := sql.Open("mysql", "root@(localhost:3306)/lib")
	if err != nil {
		return err
	}

	vulRecords := make([]VulRecord, 0)
	for _, row := range rows {
		vulRecords = append(vulRecords, VulRecord{
			VulName:      row[0],
			PackageName:  row[1],
			VersionRange: row[2],
			PublishedAt:  row[3],
			ProjectId:    row[4],
		})
	}

	type NewVulRecord struct {
		VulName     string
		PackageName string
		Versions    []string
		PublishedAt string
		ProjectId   string
	}

	parseVulRecord := func(vulRecord VulRecord) (NewVulRecord, error) {
		id, err := datasource.GetPackageIdByName(db, models.EcosystemType(ecosystemName), vulRecord.PackageName)
		if err != nil {
			return NewVulRecord{}, err
		}
		versions, err := datasource.GetVulPackageVersionsById(db, id, models.EcosystemType(ecosystemName))
		if err != nil {
			return NewVulRecord{}, err
		}
		c, err := semver.NewConstraint(vulRecord.VersionRange)
		if err != nil {
			return NewVulRecord{}, err
		}

		affectedVersionIds := make([]string, 0)
		for _, version := range versions {
			v, err := semver.NewVersion(version.VersionNumber)
			if err != nil {
				continue
			}
			if c.Check(v) {
				affectedVersionIds = append(affectedVersionIds, version.VersionId)
			}
		}

		return NewVulRecord{
			VulName:     vulRecord.VulName,
			PackageName: vulRecord.PackageName,
			Versions:    affectedVersionIds,
			PublishedAt: vulRecord.PublishedAt,
			ProjectId:   vulRecord.ProjectId,
		}, nil
	}

	newVulRecords := make([]NewVulRecord, 0)
	for _, vulRecord := range vulRecords {
		newVulRecord, err := parseVulRecord(vulRecord)
		if err != nil {
			log.Println("error: ", err, ", ", vulRecord.VersionRange)
			continue
		}
		newVulRecords = append(newVulRecords, newVulRecord)
	}

	outFile, err := os.Create(fmt.Sprintf("all_versions_%s", filePath))
	if err != nil {
		return err
	}
	outputWriter := csv.NewWriter(outFile)
	outputWriter.Write([]string{
		"vulnerability_name",
		"package_name",
		"versions",
		"published_at",
		"project_id",
	})

	for _, newVulRecord := range newVulRecords {
		outputWriter.Write([]string{
			newVulRecord.VulName,
			newVulRecord.PackageName,
			strings.Join(newVulRecord.Versions, ";"),
			newVulRecord.PublishedAt,
			newVulRecord.ProjectId,
		})
	}

	log.Println(len(vulRecords))

	return nil
}
